
### 2. Quick Start Guide

This package comes with a ready-to-use Drift 

Let's set up synchronization for a simple `Todo` model.

#### Step 1: Define Your Drift Table

In your Drift database file, define a table for your model. Make sure to include the `JustSyncTableMixin` to add the necessary synchronization columns (`updatedAt`, `scopeName`, etc.).

```dart
// lib/database.dart
import 'package:drift/drift.dart';
import 'package:just_sync/just_sync.dart';

// Assume 'Todo' is your data class, generated by Drift
part 'database.g.dart';

// 1. Define the table with the JustSyncTableMixin
@DataClassName('Todo')
class Todos extends Table with JustSyncTableMixin {
  TextColumn get id => text()();
  TextColumn get title => text()();
  BoolColumn get completed => boolean().withDefault(const Constant(false))();

  @override
  Set<Column> get primaryKey => {id};
}

@DriftDatabase(tables: [Todos, /*... other tables ...*/])
class AppDatabase extends _$AppDatabase implements IDriftDatabase {
  // ...
}
```

Your `Todo` data class (generated by `build_runner`) must implement `HasId<String>` and `HasUpdatedAt`.

#### Step 2: Create Your `LocalStore`

Create a class that extends `DriftLocalStore` to teach `just_sync` how to handle your `Todo` model.

```dart
// lib/todo_local_store.dart
import 'package:drift/drift.dart';
import 'package:just_sync/just_sync.dart';
import 'database.dart';

class TodoLocalStore extends DriftLocalStore<Todo, String> {
  // Pass your AppDatabase instance to the constructor
  TodoLocalStore(super.db);

  // Cast the generic db to your specific AppDatabase type
  AppDatabase get _db => db as AppDatabase;

  @override
  TableInfo<Todos, Todo> get table => _db.todos;

  @override
  Todo fromJson(Map<String, dynamic> json) => Todo.fromJson(json);

  @override
  String idFromString(String id) => id;

  @override
  String idToString(String id) => id;

  @override
  GeneratedColumn<Object> resolveColumn(String s) =>
      table.columnsByName[s]!;

  @override
  TodosCompanion toInsertCompanion(Todo model, SyncScope scope) =>
      TodosCompanion.insert(
        id: model.id,
        title: model.title,
        completed: Value(model.completed),
        updatedAt: model.updatedAt,
        scopeName: scope.name,
        scopeKeys: scope.keys,
      );

  @override
  TodosCompanion toUpdateCompanion(Todo model) => TodosCompanion(
        title: Value(model.title),
        completed: Value(model.completed),
        updatedAt: Value(model.updatedAt),
      );
  
  @override
  TodosCompanion toSoftDeleteCompanion() =>
      TodosCompanion(deletedAt: Value(DateTime.now().toUtc()));
}
```

#### Step 3: Configure the `RemoteStore`

Configure the `SupabaseRemoteStore` to connect to your backend.

```dart
// lib/sync_setup.dart
final supabaseClient = Supabase.instance.client;

final remoteStore = SupabaseRemoteStore<Todo, String>(
  config: SupabaseRemoteConfig(
    client: supabaseClient,
    table: 'todos', // Your Supabase table name
    idColumn: 'id',
    updatedAtColumn: 'updated_at',
    // ... other config ...
    idOf: (todo) => todo.id,
    idToString: (id) => id,
    idFromString: (id) => id,
    fromJson: (json) => Todo.fromJson(json),
    toJson: (todo) => todo.toJson(),
  ),
);
```

#### Step 4: Initialize the `SyncOrchestrator`

Bring it all together by creating an instance of `SimpleSyncOrchestrator`.

```dart
// lib/sync_setup.dart
final localStore = TodoLocalStore(AppDatabase());

final orchestrator = SimpleSyncOrchestrator<Todo, String>(
  localStore: localStore,
  remoteStore: remoteStore,
  conflictResolver: const LastWriteWinsResolver(),
);
```

#### Step 5: Synchronize and Query Data

Now you can use the orchestrator to manage your data.

```dart
// Define a scope for the current user's data
final userScope = SyncScope('todos', {'user_id': 'some-user-uuid'});

// Trigger a synchronization
try {
  await orchestrator.synchronize(userScope);
} catch (e) {
  // Handle network errors, etc.
}

// Read data from the local database
final myTodos = await orchestrator.query(userScope);

// Create a new Todo
final newTodo = Todo(
  id: 'new-uuid',
  title: 'My New Todo',
  updatedAt: DateTime.now().toUtc(),
  completed: false,
);
await orchestrator.enqueueCreate(userScope, newTodo);

// The new todo is saved locally immediately and will be synced in the background.
```

## Advanced Usage

### Custom Queries

Use `queryWith` and a `QuerySpec` to perform advanced filtering and sorting.

```dart
final incompleteTodos = await orchestrator.queryWith(
  userScope,
  const QuerySpec(
    filters: [FilterOp(field: 'completed', op: FilterOperator.eq, value: false)],
    orderBy: [OrderSpec('updatedAt', descending: true)],
  ),
);
```

### Conflict Resolution

If the default "last write wins" strategy isn't enough, you can implement your own.

```dart
class MyTodoResolver implements ConflictResolver<Todo> {
  @override
  Todo resolve(Todo local, Todo remote) {
    // Custom logic: maybe merge the titles?
    final mergedTitle = '${local.title} (local) vs ${remote.title} (remote)';
    // Always take the remote version, but with a merged title.
    return remote.copyWith(title: mergedTitle);
  }
}

// Then provide it to the orchestrator
final orchestrator = SimpleSyncOrchestrator(
  // ...
  conflictResolver: MyTodoResolver(),
);
```